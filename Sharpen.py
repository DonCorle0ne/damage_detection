# "Sharpen" an image by  multiplying every pixel by 2, and then subtracting# the average value of the neighborhood from it.#See slide number 22 from IrfanEssa-CP-02-5-Filtering.pdf## Jay Summet 2015##Python 2.7, OpenCV 2.4.x#import collectionsimport cv2import numpy as npimport pdbimport osimport matplotlib.pyplot as pltimport matplotlib as matplotfrom PIL import Image, ImageEnhance#Linux window/threading setup code.#cv2.startWindowThread()#cv2.namedWindow("Original")#cv2.namedWindow("Sharpen")#pdb.set_trace()#Load source / input image as grayscale, also works on color images...base_path = os.getcwd() + '/road_augment/'#govs = ["road_1","road_2","road_4"]govs = ["road_3","road_5","Adachi","Chiba","Muroran","Numazu","Sumida","Ichihara","Nagakute"]for gov in govs:	file_list = os.listdir(base_path + gov + '/JPEGImages/')	for file in file_list:		if file =='.DS_Store':			pass		else:			img = Image.open(os.path.join(base_path + gov + '/JPEGImages/' , file))			enhancer = ImageEnhance.Sharpness(img)			factor = 0.0			enhancer.enhance(factor).save(base_path + gov + '/JPEGImages/' + 'sh_'+ file)#cv2.imshow("Original", imgIn)#enhancer = ImageEnhance.Brightness(img)#enhancer.enhance(factor).save(base_path + gov + '/JPEGImages/' + 'br_'+ file)  #Note that we are subject to overflow and underflow here...but I believe that# filter2D clips top and bottom ranges on the output, plus you'd need a# very bright or very dark pixel surrounded by the opposite type.#pdb.set_trace()#cv2.imshow("Sharpen", custom)#cv2.waitKey(0)